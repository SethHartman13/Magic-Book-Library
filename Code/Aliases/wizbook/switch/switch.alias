embed
<drac2>


def set_default_settings(dictionary: dict, default_dictionary: dict) -> dict:
    """
    Loops through dictionary checking for missing entries and adding default ones where necessary

    Args:
        dictionary (dict): Dictionary to be checked
        default_dictionary (dict): Default dictionary

    Return:
        dict: Corrected dictionary
    """

    # For each key in the default dictionary
    for default_key in default_dictionary.keys():

        # If the value is not a dictionary
        if typeof(default_dictionary[default_key]) != "SafeDict":

            if default_key in dictionary.keys():
                pass

            else:
                dictionary[default_key] = default_dictionary[default_key]

        # If the value is a dictionary
        else:

            # Check to see if it is a threshold dictionary
            try:
                for test_key in default_dictionary[default_key].keys():
                    float(test_key)

                if default_key in dictionary.keys():
                    pass

                else:
                    dictionary[default_key] = default_dictionary[default_key]

            # If it is not a threshold dictionary, run recursive call to check values of inner dictionary
            except:
                dictionary[default_key] = set_default_settings(dictionary[default_key], default_dictionary[default_key]) 

    return dictionary


def search_list(query: str, item_list: list[str]) -> list[str]|None:
    """
    Searches for item in list.

    Args:
        query (str): The query being made
        item_list (list): List of items

    Return:
        list[str]|None: If it finds at least one match, it returns the item(s) in a list, otherwise it returns None
    """

    # Finds at least 1 match
    if len(item_results := [item for item in item_list if query.lower() in item.lower()]) > 0:
        return item_results

    # If it finds no matches
    else:
        return None


def search_spell(spell_name: str, spell_list: list[str], spell_num: int = 1) -> str|None:
    """
    
    
    """

    if (key_result := search_list(spell_name, spell_list)):

        if len(key_result) == 1:
            return key_result[0], ""

        else:

            for key in key_result:
                if key.lower() != spell_name:
                    pass

                else:
                    return key, ""

            key_result.insert(0, f"**Multiple Matches Found (Spell {spell_num}):**")

            return None, "\n".join(key_result)

    else:
        return None, f"Spell {spell_num} not found"


def compile_source_spells(source_set: set, settings_dictionary: dict) -> dict:
    """
    
    
    
    
    """

    # Load massive dictionary
    official_source = load_json(get_gvar('6011f3a8-737d-4413-9dbf-04cebe165212'))
    
    # Create empty map
    spell_dict = dict()

    for source in source_set:

        match source:
            case s if "(ai)" in s:
                spell_dict['ai'] = official_source.pop('ai')

            case s if "(eepc)" in s:
                spell_dict['eepc'] = official_source.pop('eepc')

            case s if "(egtw)" in s:
                spell_dict['egtw'] = official_source.pop('egtw')

            case s if "(ftod)" in s:
                spell_dict['ftod'] = official_source.pop('ftod')

            case s if "(ggtr)" in s:
                spell_dict['ggtr'] = official_source.pop('ggtr')

            case s if "(idrotf)" in s:
                spell_dict['idrotf'] = official_source.pop('idrotf')

            case s if "(llok)" in s:
                spell_dict['llok'] = official_source.pop('llok')

            case s if "(phb)" in s:
                spell_dict['phb'] = official_source.pop('phb')

            case s if "(sacoc)" in s:
                spell_dict['sacoc'] = official_source.pop('sacoc')

            case s if "(sais)" in s:
                spell_dict['sais'] = official_source.pop('sais')

            case s if "(scag)" in s:
                spell_dict['scag'] = official_source.pop('scag')

            case s if "(tcoe)" in s:
                spell_dict['tcoe'] = official_source.pop('tcoe')

            case s if "(tcsr)" in s:
                spell_dict['tcsr'] = official_source.pop('tcsr')

            case s if "(xgte)" in s:
                spell_dict['xgte'] = official_source.pop('xgte')

            case s if "-" in s:
                try:
                    i = 1
                    while f"HB Source {i}" in spell_dict.keys():
                        i += 1

                    spell_dict[f'HB Source {i}'] = load_json(get_gvar(source))

                except:
                    pass

            case _:
                pass

    # Empty remaining items to save memory
    for source in official_source.keys():
        official_source.pop(source)

    # Creates toss list
    toss_list = []

    # For each source
    for source in spell_dict.keys():
        source_settings = spell_dict[source].pop('SETTINGS')
        
        if settings_dictionary['SETTINGS']['Homebrew']:
            pass

        else:
            if not source_settings['Homebrew']:
                pass

            else:
                toss_list.append(source)

        if settings_dictionary['SETTINGS']['Partnered Content']:
            pass

        else:
            if not source_settings['Partnered Content']:
                pass

            else:
                toss_list.append(source)

    for source in toss_list:
        spell_dict.pop(source)

    return {spell: spell_dict[source][spell] for source in spell_list for spell in source}



def main(input_list: list[str]) -> str:
    """
    
    
    """

    if len(input_list) >= 2:

        ch = character()

        if (cvar_test != ch.get_cvar('ibook_dict')):
            cvar_dict = load_json(cvar_test)

            if "Wizard Books" in (cvar_dict_keys := cvar_dict.keys()):

                if len(cvar_dict['Wizard Books']) > 0:

                    spell_1, message = search_spell(input_list[0], [spell for wizard_book in cvar_dict['Wizard Books'].keys() for spell in (cvar_dict['Wizard Books'][wizard_book] if typeof(cvar_dict['Wizard Books'][wizard_book]) == "SafeList" else cvar_dict['Wizard Books'][wizard_book]['Dynamic'])])

                    if spell_1:
                        pass

                    else:
                        return f"{ctx.author.display_name} has encountered an error", message, "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

                else:
                    return f"{ctx.author.display_name} has encountered an error", "You have no wizard books in your library", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

            else:
                return f"{ctx.author.display_name} has encountered an error", "You have no wizard books in your library", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

        else:
            return f"{ctx.author.display_name} has encountered an error", "You have no wizard books in your library", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

    else:
        return f"{ctx.author.display_name} has encountered an error", "Expected at least two arguments", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"



    if (svar_test := get_svar("ibook_settings")):
        svar_dict = set_default_settings(load_json(svar_test), {"Settings": {"Homebrew": False, "Partnered Content": True, "Book Limit": 6, "Expanded Class": True},"Books": []})

    else:
        svar_dict = {"Settings": {"Homebrew": False, "Partnered Content": True, "Book Limit": 6, "Expanded Class": True},"Books": []}

    if (uvar_test := get_uvar("ibook_source_list")):
        uvar_list = load_json(uvar_test)

    else:
        uvar_list = []

    available_spells = compile_source_spells(set(svar_dict['Books']).union(set(uvar_list)), svar_dict)

    spell_2, message = search_spell(input_list[1], available_spells.keys(), 2)


    if spell_2:

        if "Wizard" in available_spells[spell_2]['Class']:
            pass

        else:
            if svar_dict['Settings']['Expanded Class'] and "Wizard" in available_spells[spell_2]['Expanded Class']:
                pass

            else:
                return f"{ctx.author.display_name} has encountered an error", "Spell 2 not found", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

    else:
        return f"{ctx.author.display_name} has encountered an error", message, "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

    school_rule_map = {
        "Alchemical Compendium": "tr",
        "Astromancy Archive": "di",
        "Atlas of Endless Horizons": "co",
        "Duplicious Manuscript": "il",
        "Fulminating Treatise": "ev",
        "Heart Weaver's Primer": "en",
        "Libram of Souls and Flesh": "ne",
        "Planecaller's Codex": "co",
        "Protective Verses": "ab",
        "Crystalline Chronicle": None
    }
    for magic_book in cvar_dict['Wizard Books'].keys():

        if magic_book in school_rule_map.keys():

            if school_rule_map[magic_book]:
                
                if spell_1 in cvar_dict['Wizard Books'][magic_book]:

                    if school_rule_map[magic_book] in available_spells[spell_2]["School"].lower():
                        dynamic = False
                        book_name = magic_book

                    else:
                        return f"{ctx.author.display_name} has encountered an error", "You have attempted to add a spell of the wrong school", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

                else:
                    pass

            else:
                if spell_1 in cvar_dict['Wizard Books'][magic_book]['Dynamic']:
                    dynamic = True
                    book_name = magic_book

                else:
                    pass

        else:
            if spell_1 in cvar_dict['Wizard Books'][magic_book]:
                dynamic = False
                book_name = magic_book

            else:
                pass

    try:
        if not dynamic:
            cvar_dict['Wizard Books'][book_name].pop(cvar_dict['Wizard Books'][book_name].index(spell_1))

            cvar_dict['Wizard Books'][book_name].append(spell_2)

        else:
            cvar_dict['Wizard Books'][book_name]['Dynamic'].pop(cvar_dict['Wizard Books'][book_name]['Dynamic'].index(spell_1))

            cvar_dict['Wizard Books'][book_name]['Dynamic'].append(spell_2)

    except:
        return f"{ctx.author.display_name} has encountered an error", "An unexpected error has occured", "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png", "#CF142B"

    ch.set_cvar('ibook_dict', dump_json(cvar_dict))

    return f"{name} has switched a spell in their spellbook", "\n".join(["**Magic Book:**", book_name, "", "**Removed Spell:**", spell_1, "", "**Added Spell:**", spell_2]), f"https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/wizard_read_book{randchoice(['', 1, 2, 3, 4, 5])}.png", ""

            
title, f, thumb, color = main(&ARGS&)


</drac2>
-title "{{title}}"
-f "{{f}}"
-thumb "{{thumb}}"
-color "{{color}}"
embed
<drac2>


def search_list(query: str, item_list: list[str]) -> list[str]|None:
    """
    Searches for item in list.

    Args:
        query (str): The query being made
        item_list (list): List of items

    Return:
        list[str]|None: If it finds at least one match, it returns the item(s) in a list, otherwise it returns None
    """

    # Finds at least 1 match
    if len(item_results := [item for item in item_list if query.lower() in item.lower()]) > 0:
        return item_results

    # If it finds no matches
    else:
        return None


def subtract_counter(result_key: list[str], ch: character) -> str, bool:
    """
    Subtracts from a counter associated with the book found

    Args:
        result_key (list[str]): List of matches found
        ch (character): Character object

    Return:
        str|None: Name of cc incremented (or None if none were incremented)
    """

    def split_name(name: str) -> str:
        """
        Removes number off of book name\

        Args:
            name (str): Book name

        Return
            str: Name of book without number
            bool: Whether it did tick down a CC
        """

        # Makes temporary list
        temp_list = name.split()

        # Removes last item (number)
        temp_list.pop(-1)

        # Returns the new string
        return " ".join(temp_list)

    # For each item in the result_key
    for item in result_key

        # Try to get the cc of the book name
        try:
            book_cc = ch.cc(item)

            # If value is not 0
            if book_cc.value > book_cc.min:

                # Subtract one
                book_cc.mod(-1)

                # Return split_name and True
                return split_name(book_name), True

            # If value is 0
            else:
                book_name = item

        # If the CC does not exist
        except:
            book_name = item
        
    # If it does not find a CC to tick down, returns name and False
    return split_name(book_name), False


def magic_book_activator(book_name: str, input_list: list[str], ch: character) -> str, str, str, str:
    """
    Activates the magic book and applies necessary effects
    
    Args:
        book_name (str): Name of book
        input_list (list[str]): List of inputs
        ch (character): Character object

    Return:
        str: Title
        str: Content
        str: Image URL
        str: Color hex code    
    """
    
    # Combat object
    com = combat()

    # Parsed args
    parsed_args = argparse(" ".join(input_list))
    t_arg = parsed_args.get("t")
    amt_arg = parsed_args.last("amt", default=0)
    crit_arg = parsed_args.last("crit")

    # Alchemical Compendium
    if "alchem" in book_name.lower():
        return f"{name} ({ctx.author.display_name}) uses their Alchemical Compendium", "As an action, you can touch a nonmagical object that isn't being worn or carried and spend a number of charges to transform the target into another object. For 1 charge, the object can be no larger than 1 foot on a side. You can spend additional charges to increase the maximum dimensions by 2 feet per charge. The new object must have a gold value equal to or less than the original.", image, "#B47F47"

    # Astromancy Archive
    elif "astrom" in book_name.lower():
        return f"{name} ({ctx.author.display_name}) uses their Astromancy Archive", f"{vroll("1d4").full}\nWhen a creature you can see within 30 feet of you makes an attack roll, an ability check, or a saving throw, you can use your reaction to expend 1 charge and force the creature to roll a d4 and apply the number rolled as a bonus or penalty (your choice) to the original roll. You can do this after you see the roll but before its effects are applied.", image, "#8CA5B7"


    elif "atlas" in book_name.lower():

        # Turns amt_arg into an integer
        try:
            amt_arg = int(amt_arg)

        # If it is not an integer
        except:
            amt_arg = 0

        # If amount is not 0
        if amt_arg != 0:

            # If the player did not have thp
            if ch.hp + amt_arg <= ch.max_hp:
                add_string = f"{ch.modify_hp(amt_arg, overflow=False)} (+{amt_arg})\n"

            # If the player did have thp
            else:
                ch.set_temp_hp(ch.hp + amt_arg - ch.max_hp)
                ch.set_hp(ch.max_hp)
                add_string = f"{ch.hp_str()} (+{amt_arg})\n"

        # If amount was 0
        else:
            add_string = ""

        return f"{name} ({ctx.author.display_name}) uses their Atlas of Endless Horizons", f"{add_string}When you are hit by an attack, you can use your reaction to expend 1 charge to teleport up to 10 feet to an unoccupied space you can see. If your new position is out of range of the attack, it misses you.", image, "#F5DA67"

    # Duplicious Manuscript
    elif "dupli" in book_name.lower():
        return f"{name} ({ctx.author.display_name}) uses their Atlas of Endless Horizons", f"When a creature you can see makes an Intelligence (Investigation) check to discern the true nature of an illusion spell you cast, or makes a saving throw against an illusion spell you cast, you can use your reaction and expend 1 charge to impose disadvantage on the roll.", image, "#C69FFB"

    elif "fulmi" in book_name.lower():

        if not crit_arg:
            pass

        else:
            crit_arg = True

        target_name = "Meta"

        if crit_arg:
            dmg_dict = {"roll": vroll("4d6[force]")}
            dmg_dict['damage'] = f"**Damage (CRIT!)**: {dmg_dict['roll'].full}"
            dmg_dict['total'] = dmg_dict['roll'].total

        else:
            dmg_dict = {"roll": vroll("2d6[force]")}
            dmg_dict['damage'] = f"**Damage**: {dmg_dict['roll'].full}"
            dmg_dict['total'] = dmg_dict['roll'].total

        dmg_str = dmg_dict['damage']
        dmg_total = dmg_dict['total']
        dmg_roll_obj = dmg_dict['roll']

        hp_str = "\n"

        if com:
            target = com.get_combatant(t_arg[0])

            if target:

                if (target_name := target.monster_name):
                    hide_hp = True
                    
                else:
                    target_name = target.name
                    hide_hp = False

                dmg_dict = target.damage("2d6[force]", crit=crit_arg)

                dmg_str = dmg_dict['damage']
                dmg_total = dmg_dict['total']
                dmg_roll_obj = dmg_dict['roll']

                target.add_effect("Prone", args=f"dis", desc="An attack roll against the creature has advantage if the attacker is within 5 feet of the creature. Otherwise the Attack roll has disadvantage", buttons={
                    "label": "Stand Up (Prone)",
                    "style": 1,
                    "verb": "Stands Up",
                    "automation": {type: "remove_ieffect"}
                    })

                if hide_hp:
                    if target.hp > target.max_hp / 2:
                        hp_str = "<injured>\n"

                    elif target.hp > target.max_hp / 10:
                        hp_str = "<bloodied>\n"

                    else:
                        hp_str = "<critical>\n"

                else:
                    if target.temp_hp > 0:
                        tmp_str = f" ({target.temp_hp} temp)\n"

                    else:
                        tmp_str = "\n"

                    hp_str = f"<{target.hp}>{tmp_str}"
            
            else:
                pass

        else:
            pass

        return f"{name} ({ctx.author.display_name}) uses their Fulminating Treatise", f"**{target_name}**\n{dmg_str}\n{hp_str}\nWhen one creature you can see takes damage from an evocation spell you cast, you can use your reaction and expend 1 charge to deal an extra 2d6 force damage to the creature and knock the creature prone if it is Large or smaller.", image, "#D6614E"

    # Heartweaver's Primer
    elif "heart" in book_name.lower():
        return f"{name} ({ctx.author.display_name}) uses their Heart Weaver's Primer", "When you cast an enchantment spell, you can expend 1 charge to impose disadvantage on the first saving throw one target makes against the spell.", image, "#ED90D9"

    # Write add_effect
    elif "libram" in book_name.lower():
        return f"{name} ({ctx.author.display_name}) uses their Libram of Souls and Flesh", "When you cast an enchantment spell, you can expend 1 charge to impose disadvantage on the first saving throw one target makes against the spell.", image, "#B6ED89"

    # Write add_effect
    elif "plane" in blook_name.lower():
        return f"{name} ({ctx.author.display_name}) uses their Planecaller's Codex", "When you cast a conjuration spell that summons or creates one creature, you can expend 1 charge to grant that creature advantage on attack rolls for 1 minute.", image, "#F5DA67"

    # Write add thp
    else:
        return f"{name} ({ctx.author.display_name}) uses their Protective Verses", "When you cast an abjuration spell, you can expend 1 charge to grant a creature you can see within 30 feet of you 2d10 temporary hit points.", image, "#69AFEC"


def main(input_list: list[str]) -> str, str, str, str:
    """
    Main program function

    Args:
        input_list (list[str]): List of inputs

    Return:
        str: Title
        str: Content
        str: Image URL
        str: Color hex code
    """
    
    # Character object, error color, and error image url
    ch = character()
    color = "#CF142B"
    img_url = "https://raw.githubusercontent.com/SethHartman13/Magic-Book-Library/main/Code/Images/no_wizard.png"

    # If there is at least one input
    if len(input_list) > 0:

        # Tries to grab dictionary from cvar
        ibook_test = ch.get_cvar("ibook_dict")

        # If cvar exists, load dictionary
        if ibook_test:
            ibook_dict = load_json(ibook_test)

            # Check for existance of wizard books
            try:

                # If there is at least one entry
                if len(ibook_dict["Wizard Books"].keys()) > 0:
                    pass

                # If there are no entries in the Wizard Books
                else:
                    return f"{ctx.author.display_name} has encountered an error", "There are no wizard books in your `ibook_dict`", img_url, color
        
            # If the wizard books key doesn't exist
            except:
                return f"{ctx.author.display_name} has encountered an error", "There are no wizard books in your `ibook_dict`", img_url, color

        # If the cvar does not exist
        else:
            return f"{ctx.author.display_name} has encountered an error", "There are no wizard books in your `ibook_dict`", img_url, color

        # Search for the input that was given
        result_key = search_list(input_list[0], ibook_dict["Wizard Books"].keys())

        # If it finds at least one book
        if result_key:
            
            # Ticks down counter (if possible)
            book_name, counter_change = subtract_counter(result_key, ch)

            # If there was a counter change, activate book
            if counter_change:
                return magic_book_activator(book_name, input_list, ch)

            # If there was not a counter change, do not activate book.
            else:
                return f"{ctx.author.display_name} has encountered an error", f"You have no counters left for {book_name}", img_url, color

        # If it does not find a book
        else:
            return f"{ctx.author.display_name} has encountered an error", f"Book not found", img_url, color

    # If no inputs were given
    else:
        return f"{ctx.author.display_name} has encountered an error", f"Expected at least one input", img_url, color


# Main program function
title, f, thumb, color = main(&ARGS&)


</drac2>
-title "{{title}}"
-f "{{f}}"
-thumb "{{thumb}}"
-color "{{color}}"